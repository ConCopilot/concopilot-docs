# Plugin

[TOC]

## The `Plugin` interface

### Methods of the `Plugin` interface

Source code: [plugin.py](https://github.com/ConCopilot/concopilot/blob/v0.0.1/concopilot/framework/plugin/plugin.py)
<br>
Config file example: [config.yaml](https://github.com/ConCopilot/concopilot/blob/v0.0.1/config/plugin/config.yaml)

The Plugin methods can be grouped into 3 parts: configuration, data & property, and interaction.

#### The configuration Methods

Methods in this group is used to configure and initialize the plugin. 

##### `def __init__(self, config: Dict)`

A plugin is constructed by its related "config.yaml" file.
The `config` parameter contains all information in the "config.yaml" file.
All necessary framework references should be configured here,
but no resource should be initialized.

##### `def config_resources(self, resource_manager: ResourceManager)`

Configure the plugin resources from the `resource_manager`.
Only the resources that are configured in both the plugin and the `resource_manager`'s "config.yaml" are valid.

This method should be called after all resources managed by the `resource_manager` have been initialized.
Thus, the plugin can safely use its resources in this method and after this method being called.

##### `def config_context(self, context: Context)`

Configure the context for this plugin, and for all components under this plugin if necessary.

After this method bing called,
the plugin can access its `context` by its [`plugin.context`](#context-property) property.

##### `def config_file_path(self, file_name: str = None) -> str`

This method will return the config file path with the given `file_name` of this plugin.
If the `file_name` is `None`, the path of the default "config.yaml" will be returned.

The config file here is a general concept that indicates any file that is related to this plugin and has been pushed into the component repository.

Please note that this method does NOT check the file existence.

#### The data & property Methods

Methods in this group is used to access the plugin properties.

##### `config` property

Return the plugin config dict which should be the same one that construct this plugin, but in `ClassDict` type.

##### Component Identifiers

###### `group_id` property

The component group id string.

###### `artifact_id` property

The component artifact id string.

###### `version` property

The component version string.

##### Instance Identifiers

###### `id` property

The id of the plugin instance in `Union[uuid.UUID, str]`.

###### `name` property

The name of the plugin instance.

##### `type` property

The type (the `type` field in the "config.yaml") of the plugin.
All special plugins have their own special type.
All pure plugins should have the type "plugin".

##### `as_plugin` property

The plugin's `as_plugin` attribute (the `as_plugin` field in the "config.yaml").
Special Plugins may return `False` if the author only want them acting in defined logics without a need to interact with the LLMs.
On the other hand, any component that is supposed to be used as a supporting tools of the LLMs should return `True` here.

##### Plugin Resources

###### `resources` property

Returns the plugin resource list (`List[Resource]`).

###### `resource_id_map` property

Returns the plugin resource map (`Dict[Union[uuid.UUID, str], Resource]`) arranged by the resource id.

###### `resource_name_map` property

Returns the plugin resource map (`Dict[str, Resource]`) arranged by the resource name.

###### `resource_type_map` property

Returns the plugin resource map (`Dict[str, List[Resource]]`) arranged by the resource type.

###### `def get_resource(self, *, resource_id: str = None, resource_name: str = None, resource_type: str = None) -> Optional[Resource]`

Retrieve a resource with its resource id, resource name, and resource_type.

if the `resource_id` is "default", it will be ignored.

If the `resource_type` is provided alone, the first resource with the given resource type will be returned.

##### `context` property

Return the plugin [context](../introduction/concepts.md#context).

##### `prompt` property

The getter and setter of the plugin prompt.

This prompt may be used in the interaction between the plugin and the LLMs,
depending on the `Interactor` implementation.

The plugin prompt can either be pre-defined in the plugins "config.yaml" or be generated by the `plugin_prompt_generator` of a Plugin Manager.

#### The interaction Methods

Methods in this group is mainly used to interact with other parts of the copilot, especially the `Interactor` and `Cerebrum` (LLM).

##### `def command(self, command_name: str, param: Dict, **kwargs) -> Dict`

This is the raw (without message encapsulation) plugin command execution interface.

Implement this method if the component is supposed to be a real full functional plugin.

This method accept 3 parameters:

1. `command_name`: the command name to call.
2. `param`: the command parameters.
3. `kwargs` reserved, not recommend to use.

And returns the command execution result.

##### `def send_msg(self, msg: Message)`

Send a message to this plugin without waiting the response.

The `command` method will be called to run the command in the `msg` content.

##### `def on_msg(self, msg: Message) -> Message`

Send a message to this plugin and waiting for a response.

The `command` method will be called to run the command in the `msg` content.

This method will interpret the message content,
call the `command` method,
and translate the `command` result into another message back to the `sender`. 

##### `def has_msg(self) -> bool`

Check if the plugin has a message to be sent out.
Call the `get_msg` method to retrieve the message if this method returns `True`.

##### `def get_msg(self) -> Optional[Message]`

Retrieve the first message this plugin is about to send or `None`.

## The `AbstractPlugin` class

Source code: [plugin.py](https://github.com/ConCopilot/concopilot/blob/v0.0.1/concopilot/framework/plugin/plugin.py)

It looks very complex for the `Plugin` interface.
Fortunately, ConCopilot has implemented most of the interface methods for common use.
Developers only need to do 2 things in most cases:

1. Implement the `__init__` method.

    Doing your own class initialization like developing other python classes.
    Doing some config rearrangement in the `__init__` function if necessary by accessing the `self.config` property.

2. Implement the `command` method.

    This method will control the core logics of your plugin,
    so you need to implement it with your own logic.

See more examples [here](https://github.com/ConCopilot/concopilot/tree/v0.0.1/concopilot_examples/plugin). 
